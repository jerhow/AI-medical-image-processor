@page
@model MedicalImageAI.Web.Pages.UploadModel
@{
    ViewData["Title"] = "Upload Medical Image for Analysis";
}

<h1>@ViewData["Title"]</h1>

<div class="row">
    <div class="col-md-8">
        <p>Select an image file (PNG, JPG, JPEG, BMP - Max 4MB) to upload for analysis.</p>
        <p>Analysis will be performed in the background. This page will confirm if your upload was accepted for processing.</p>
        
        <form method="post" enctype="multipart/form-data" class="mt-4">
            <div asp-validation-summary="ModelOnly" class="text-danger"></div> @* Shows model-level errors *@

            <div class="mb-3">
                <label asp-for="UploadedImage" class="form-label">Choose Image:</label>
                <input asp-for="UploadedImage" class="form-control" type="file" required>
                <span asp-validation-for="UploadedImage" class="text-danger"></span>
            </div>
            
            <button type="submit" class="btn btn-primary">Upload and Queue for Analysis</button>
        </form>
    </div>
</div>

@* Area to display initial acceptance and then polled results *@
<div class="row mt-4">
    <div class="col-md-8">
        @if (Model.PageResponse != null) // After initial POST and 202 Accepted
        {
            <div id="uploadConfirmation" class="alert alert-success" role="alert">
                <h4 class="alert-heading">Request Accepted!</h4>
                <p>@Model.PageResponse.Message</p>
                <p class="mb-0">Server Filename: <strong>@Model.PageResponse.FileName</strong></p>
                <p class="mt-2">Attempting to fetch analysis results...</p>
            </div>
        }

        @* This div will be updated by JavaScript polling *@
        <div id="analysisResultsArea" class="mt-3"></div>

        @if (!string.IsNullOrEmpty(Model.ErrorMessage))
        {
            <div id="uploadError" class="alert alert-danger mt-3" role="alert">
                <h4 class="alert-heading">An error occurred:</h4>
                <p>@Model.ErrorMessage</p>
            </div>
        }
    </div>
</div>

@* In Pages/Upload.cshtml, where your CSV download button is *@
<hr class="mt-5 mb-4" />
<div class="row">
    <div class="col-md-8">
        <h3>Download Full Analysis Report</h3>
        <p>Download a CSV file containing all image analysis job details and their primary results.</p>
        <a asp-page="/Upload" asp-page-handler="DownloadCsvReport" class="btn btn-info">Download CSV Report</a>
    </div>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

    @* Polling for whether a JobId is available, and fetching the results + updating the UI if so *@
    @if (Model.PageResponse?.JobId != null && Model.PageResponse.JobId != Guid.Empty)
    {
        <script>

            @* Helper function to escape HTML to remove some XSS vectors *@
            function escapeHtml(unsafe) {
                if (unsafe === null || typeof unsafe === 'undefined') return '';
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            (function () {
                const jobId = "@Model.PageResponse.JobId";
                @* In this case, PageModel exposes Configuration as a public property.
                   Alternatively, we could have injected IConfiguration into the view. *@
                const apiBaseUrl = "@Model.Configuration["ApiSettings:BaseUrl"]"; // Ensure Configuration is injected into UploadModel and accessible
                const statusUrl = `/Upload?handler=AnalysisStatus&jobId=${jobId}`;
                const resultsArea = document.getElementById("analysisResultsArea");
                let pollingInterval = 3000; // Poll every 3 seconds
                let maxPollAttempts = 20; // Stop after 20 attempts (1 minute)
                let pollAttempts = 0;

                function displayResults(data) {
                    resultsArea.innerHTML = ''; // Clear previous messages
                    let content = `<h5>Analysis Complete (Job ID: ${data.jobId})</h5>`;
                    content += `<p><strong>Status:</strong> <span class="badge bg-${data.status === 'Completed' ? 'success' : 'danger'}">${data.status}</span></p>`;
                    
                    if (data.analysis && data.analysis.success && data.analysis.predictions && data.analysis.predictions.length > 0) {
                        content += '<p><strong>Predictions:</strong></p><ul>';
                        data.analysis.predictions.forEach(pred => {
                            content += `<li>${pred.tagName}: ${pred.probability.toFixed(1)}%</li>`;
                        });
                        content += '</ul>';
                    } else if (data.analysis && !data.analysis.success && data.analysis.errorMessage) {
                        content += `<p class="text-danger"><strong>Analysis Error:</strong> ${data.analysis.errorMessage}</p>`;
                    } else if (data.status === 'Failed' && data.analysis && data.analysis.errorMessage) {
                        content += `<p class="text-danger"><strong>Analysis Failed:</strong> ${data.analysis.errorMessage}</p>`;
                    } else if (data.status === 'Failed') {
                         content += `<p class="text-danger"><strong>Analysis Failed:</strong> No detailed error message available.</p>`;
                    }
                     else {
                        content += '<p>No predictions available or analysis did not complete successfully.</p>';
                    }

                    if (data.analysis && data.analysis.hasOwnProperty('ocrText')) { // Check if ocrText property exists
                        content += '<hr/><h6>Extracted Text (OCR):</h6>';
                        if (data.analysis.ocrText && data.analysis.ocrText.trim() !== "" && data.analysis.ocrText !== "No text blocks found") { // Check if there's actual text
                            @* Using <pre> to preserve formatting like line breaks from the OCR result *@
                            content += `<pre style="white-space: pre-wrap; word-wrap: break-word; border: 1px solid #ccc; padding: 10px; background-color: #f9f9f9;">${escapeHtml(data.analysis.ocrText)}</pre>`;
                        } else {
                            content += `<p><em>${escapeHtml(data.analysis.ocrText) || "No text blocks found by OCR."}</em></p>`;
                        }
                    }
                    resultsArea.innerHTML = content;
                }

                function pollForStatus() {
                    pollAttempts++;
                    if (pollAttempts > maxPollAttempts) {
                        resultsArea.innerHTML = '<p class="text-warning">Stopped polling for results after 1 minute. Please check back later or try again.</p>';
                        return;
                    }

                    resultsArea.innerHTML = `<p>Checking analysis status (attempt ${pollAttempts})... <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span></p>`;
                    
                    fetch(statusUrl)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Network response was not ok: ${response.statusText}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === "Completed" || data.status === "Failed" || data.status.startsWith("Error")) {
                                displayResults(data);
                                // Stop polling
                            } else if (data.status === "Processing" || data.status === "Queued") {
                                resultsArea.innerHTML = `<p>Status: ${data.status}. Will check again in ${pollingInterval / 1000} seconds... <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span></p>`;
                                setTimeout(pollForStatus, pollingInterval);
                            } else {
                                // Unexpected status
                                resultsArea.innerHTML = `<p class="text-warning">Received unexpected status: ${data.status}. Stopping polling.</p>`;
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching analysis status:', error);
                            resultsArea.innerHTML = `<p class="text-danger">Error fetching analysis status: ${error.message}. Please try refreshing.</p>`;
                            @* Optionally stop polling on error or retry a few times *@
                        });
                }

                // Start polling immediately after the initial 202 Accepted response is handled by the server-side Razor Page
                if (jobId && apiBaseUrl) {
                    console.log("Starting polling for Job ID:", jobId, "at URL:", statusUrl);
                    pollForStatus();
                } else {
                    if (!jobId) console.error("JobId not available to start polling.");
                    if (!apiBaseUrl) console.error("API Base URL not available to start polling.");
                    resultsArea.innerHTML = "<p class='text-danger'>Could not start polling: Configuration missing.</p>"
                }
            })();
        </script>
    }
}
